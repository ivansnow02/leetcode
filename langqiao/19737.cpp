// 问题描述
// 在蓝桥王国，国王统治着一支由 n 个小队组成的强大军队。每个小队都由相同职业的士兵组成。具体地，第 i 个小队包含了 b_i
// 名职业为 a_i 的士兵。

// 近日，国王计划在王宫广场举行一场盛大的士兵检阅仪式，以庆祝王国的繁荣昌盛。然而，在士兵们入场的过程中，一场突如其来的风暴打乱了他们的行列，使得不同小队的士兵混杂在一起，次序乱成一团。

// 尽管国王无法知道每个士兵的具体职业，但为了确保仪式能顺利进行，国王打算从这些混乱的士兵中选出一部分，组成 k
// 个“纯职业小组”进行检阅。一个“纯职业小组”定义为由 3 名同职业的士兵组成的队伍。

// 请问，国王至少需要选择多少名士兵，才能确保这些士兵可以组成 k 个“纯职业小组”。

// 输入格式
// 输入包含多组数据。

// 第一行包含一个整数 T，表示有 T 组数据。

// 对于每组数据：

// 第一行包含两个整数 n 和 k，表示小队的数量和要组成的纯职业小组的数量。
// 接下来的 n 行，每行包含两个整数 a_i 和 b_i，表示第 i 个小队中士兵的职业和数量。

// 输出格式
// 对于每组数据，输出一个整数，表示为了组成 k 个“纯职业小组”，国王至少需要选择的士兵数量。如果无论如何也无法组成 k
// 个“纯职业小组”，则输出 -1。 样例输入
// 2
// 3 2
// 1 3
// 2 3
// 3 3
// 3 5
// 1 3
// 2 3
// 3 3
// copy
// 样例输出
// 8
// -1
// copy
// 样例说明
// 在第一个样例中，要想组成
// 2 个“纯职业小组”，国王至少需要选择 8 名士兵。若只选择了 7 名士兵，则这 7 名士兵的职业可能为 1,1,1,2,2,3,3，无法组成 2
// 个“纯职业小组”。

// 在第二个样例中，即使选择了所有士兵，也无法组成 5 个“纯职业小组”，因此输出 −1。


#include <bits/stdc++.h>

using namespace std;

unordered_map<int, long long> umap;

void solve() {
    long long n, k;
    cin >> n >> k;
    // 每组测试前清空 map
    umap.clear();

    // 统计不同职业的士兵总数
    for (int i = 0; i < n; i++) {
        int a, b;
        cin >> a >> b;
        umap[a] += b;
    }

    // 根据题意，先将 k 减 1，最后答案再加 1
    k--;
    // sum：所有兵种中直接能组成的完整 3 人组的总数（即每个兵种数除以 3 的总和）
    long long sum = 0;
    // res：模拟选兵数的累积（其实是"选兵"的下界）
    long long res = 0;
    // cnt：记录每个兵种超出安全数量（≤2）后，能完整贡献几个 3 人组（不包括余数部分）的总数
    long long cnt = 0;
    // f 数组用来统计超出2人后余数为1或2的个数
    int f[3] = {0, 0, 0};

    // 遍历每种兵种
    for (auto &e: umap) {
        long long x = e.second;
        // 计算直接能组成的整组数
        sum += x / 3;
        if (x <= 2) {
            // 安全选择，直接把 x 个人选了
            res += x;
        } else {
            // 至少安全选择 2 人
            res += 2;
            // 此兵种额外能组成的整组数
            cnt += ((x - 2) / 3);
            // 记录余数情况
            f[(x - 2) % 3]++;
        }
    }

    // 如果所有兵种凑出的整组数不足目标，说明不可能构成 k+1 个纯职业小组
    if (sum < k) {
        cout << -1 << "\n";
        return;
    }

    // 用完整的额外组来补充需要的纯职业小组
    long long use = min(cnt, k);
    res += use * 3;
    k -= use;

    // 对于剩下不足的组数，先利用余数为2的，再利用余数为1的
    for (int i = 2; i >= 1 && k > 0; i--) {
        long long tx = min((long long) f[i], k);
        k -= tx;
        res += tx * i;
    }

    // 最后答案为累加选兵数+1
    cout << res + 1 << "\n";
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int T;
    cin >> T;
    while (T--) {
        solve();
    }
    return 0;
}
