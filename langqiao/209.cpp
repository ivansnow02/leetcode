// 翻硬币

// 题目描述
// 小明正在玩一个"翻硬币"的游戏。

// 桌上放着排成一排的若干硬币。我们用 * 表示正面，用 o 表示反面（是小写字母，不是零）。

// 比如，可能情形是：**oo***oooo;

// 如果同时翻转左边的两个硬币，则变为：oooo***oooo。

// 现在小明的问题是：如果已知了初始状态和要达到的目标状态，每次只能同时翻转相邻的两个硬币,那么对特定的局面，最少要翻动多少次呢？

// 我们约定：把翻动相邻的两个硬币叫做一步操作。

// 输入描述
// 两行等长的字符串，分别表示初始状态和要达到的目标状态。

// 每行的长度<1000。

// 输出描述
// 一个整数，表示最小操作步数。

// 输入输出样例
// 示例
// 输入

// **********
// o****o****
// copy
// 输出

// 5
// copy
// 运行限制
// 最大运行时间：1s
// 最大运行内存: 64M

// 从左向右扫描数组，对于每个位置 i，如果 D[i] 为 1，则必须将它翻转。由于只能同时翻转 i 和 i+1，所以在位置 i 为 1 时，我们立即对 (i, i+1) 进行翻转操作，这样保证位置 i 得到正确状态；此时 D[i+1] 的状态也会改变。

#include <bits/stdc++.h>

using namespace std;
using i64 = long long;

int main() {
    ios::sync_with_stdio(0), cin.tie(nullptr);

    string s1, s2;

    cin >> s1 >> s2;

    auto flip = [](char &c) {
        if (c == '*')
            c = 'o';
        else c = '*';
    };

    i64 ans = 0;
    for (int i = 0; i < s1.size() - 1; i++) {
        if (s1[i] != s2[i]) {
            flip(s1[i]);
            flip(s1[i + 1]);
            ans++;
        }
    }
    cout << ans << endl;
}
