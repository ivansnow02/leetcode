// 题目描述
// 小明最近在玩一款游戏。对游戏中的防御力很感兴趣。

// 我们认为直接影响防御的参数为"防御性能"，记作 d，而面板上有两个防御值 A 和 B，与 d 成对数关系，A = 2^d，B = 3^d（注意任何时候上式都成立）。

// 在游戏过程中，可能有一些道具把防御值 A 增加一个值，有另一些道具把防御值 B 增加一个值。

// 现在小明身上有 n1 个道具增加 A 的值和 n2 个道具增加 B 的值，增加量已知。

// 现在已知第 i 次使用的道具是增加 A 还是增加 B 的值，但具体使用那个道具是不确定的，请找到一个字典序最小的使用道具的方式，使得最终的防御性能最大。

// 初始时防御性能为 0，即 d=0，所以 A=B=1。

// 输入描述
// 输入的第一行包含两个数 n1, n2，空格分隔。

// 第二行 n1 个数，表示增加 A 值的那些道具的增加量。

// 第三行 n2 个数，表示增加 B 值的那些道具的增加量。

// 第四行一个长度为 n1+n2 的字符串，由 0 和 1 组成，表示道具的使用顺序。0 表示使用增加 A 值的道具，1 表示使用增加 B 值的道具。输入数据保证恰好有 n1 个 0，n2 个 1 。

// 其中，字符串长度 ≤ 2×10^6 ，输入的每个增加值不超过 2^30 。

// 输出描述
// 对于每组数据，输出 n1 + n2 + 1 行。

// 前 n1 + n2 行按顺序输出道具的使用情况，若使用增加 A 值的道具，输出 Ax，x 为道具在该类道具中的编号（从 1 开始）。若使用增加 B 值的道具则输出 Bx。

// 最后一行输出一个大写字母 E 。

// 输入输出样例
// 示例
// 输入
// 1 2
// 4
// 2 8
// 101

// 输出
// B2
// A1
// B1
// E

// 运行限制
// 最大运行时间：1s
// 最大运行内存: 256M

// B 先后两次加上相同的增加量，但是这两次导致的 A 值的增长幅度不一样。
// 前一次 A 值增长多，后一次 A 值增长少。
// 说明前面对 A 值的提升性能强。
// 所以，将 B 的增加量按从大到小排序，这样可以使 A 值的总体增长幅度更大。

// A 先后两次加上相同的增加量，但是这两次导致的 B 值的增长幅度不一样。
// 前一次 B 值增长少，后一次 B 值增长多。
// 说明后面对 B 值的提升性能强。
// 所以，将 A 的增加量按从小到大排序，这样可以使 B 值的总体增长幅度更大。

#include <bits/stdc++.h>
using namespace std;
using i64 = long long;

struct Def {
    i64 id;
    i64 v;
    Def(i64 i) : id(i + 1) {}
};

int main() {
    ios::sync_with_stdio(0), cin.tie(nullptr);

    i64 n1, n2;
    cin >> n1 >> n2;

    vector<Def*> As(n1), Bs(n2);

    for (int i = 0; i < n1; i++) {
        As[i] = new Def(i);
        cin >> As[i]->v;
    }
    for (int i = 0; i < n2; i++) {
        Bs[i] = new Def(i);
        cin >> Bs[i]->v;
    }

    sort(As.begin(), As.end(), [](auto a, auto b) {
        if (a->v == b->v) {
            return a->id < b->id;
        }
        return a->v < b->v;
    });

    sort(Bs.begin(), Bs.end(), [](auto a, auto b) {
        if (a->v == b->v) {
            return a->id < b->id;
        }
        return a->v > b->v;
    });

    string s;
    cin >> s;

    i64 ai = 0, bi = 0;
    for (const auto &c : s) {
        if (c == '0') {
            cout << "A" << As[ai++]->id << endl;
        } else
            cout << "B" << Bs[bi++]->id << endl;
    }

    cout << "E" << endl;





}
