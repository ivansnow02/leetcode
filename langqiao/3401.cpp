// 肖恩根据这两种特殊卡牌的规则给自己的大富翁设计了一种新的特殊卡牌平局卡。平局卡可以同时选住
// V 名玩家，并使这 V 名（V ∈ [1, cnt 玩家数]）玩家拥有的金币平均以后分给每个人。每个人在游戏开始时拥有的金币数是
// A[i]，肖恩认为金币数高于 X 的为富人。请你帮肖恩求出使用任意多次（可以是 0 次）平局卡以后最多有多少富人。

// 输入描述
// 首先输入一个整数 t，表示测试数据的数量。

// 对于每一组测试数据，
// 第一行输入两个整数 n 和 x，分别表示玩家的数量和肖恩认为的富人最少拥有的金币数。
// 第二行输入 n 个整数，第 i 个整数 A[i] 表示第 i 个玩家在游戏开始时的金币数。

// 数据保证 1 ≤ t ≤ 1000, 1 ≤ n ≤ 10^5, 1 ≤ x ≤ 10^9, 1 ≤ A[i] ≤ 10^9。其中，对于所有测试数据保证 n 的和不超过 10^5。

// 输出描述
// 对于每个测试数据，输出一个整数表示使用任意多次平局卡以后可能的最大的富人数量。

// 样例输入
// 3
// 5 2
// 1 2 3 4 5
// 5 4
// 1 2 3 4 5
// 5 3
// 1 213 76 114 514

// 样例输出
// 5
// 3
// 5

// 说明
// 对于第一个测试数据，我们可以选中所有玩家，他们的金币平均值为 (1 + 2 + 3 + 4 + 5) / 5 = 15 / 5 = 3，高于肖恩的富人标准
// 2，所以最多可以都是富人。

#include <bits/stdc++.h>
#include <functional>
using namespace std;
using i64 = long long;

i64 t, n, x;

int main() {
    ios::sync_with_stdio(0), cin.tie(nullptr);

    cin >> t;
    while (t--) {
        cin >> n >> x;
        vector<i64> players(n);

        for (i64 i = 0; i < n; i++) {
            cin >> players[i];
        }

        sort(players.begin(), players.end(), greater<i64>());

        i64 sum = 0, ans = 0;
        for (i64 i = 0; i < n; i++) {
            sum += players[i];
            if (double(sum) / (i + 1) >= x) {
                ans = i + 1;
            }
        }
        cout << ans << endl;
    }
}
